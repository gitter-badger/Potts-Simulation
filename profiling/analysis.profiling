*** File /home/deathquasar/Projects/MHPC/neuro/funzioni_restyle.cpp:
                ///	%%%%%%%%%%%%%%%%%%		CONNECTIVITY		%%%%%%%%%%%%%%%%%
                extern int    	 	**xi;							
                extern float   	**s;
                extern float    	**sold;	
                extern float    	****J;		/// 33333333333333333333333
                //extern float	mark[N]; 				/// per costruire una cue correlata con un pattern
                extern float    	m[p];
                extern float    	mS[p];
                extern int       	retr;
                extern float    	**h; 
                extern float		**r;						
                extern float    	q; 
                extern float		**theta;
                extern float		n0;
                extern float    	invdenN;
                extern float    	denCm;
                extern float   	**overlap;
                extern int 		**Permut;
                extern int 		**C;		/// 33333333333333333333333
                extern float		H, Hq, Hht, A;
                extern float	ws;
                extern float SS1[N][S+1];
                extern float theta1[N][S];
                extern float rr1[N][S+1];
                
                extern FILE *pat;
                extern FILE *mvari;
                extern FILE *Hfile;
                extern FILE *Hqfile;
                extern FILE *Hhtfile;
                extern FILE *Afile;
                extern FILE *Tfile;
                extern FILE *DTfile;
                extern FILE *DT0file;
                extern FILE *DSfile;
                extern FILE *R0file;
                extern FILE *A1file;
                extern FILE *A2file;
                extern FILE *S1;
                extern FILE *th1;
                extern FILE *r1;
                extern FILE *h1;
                extern FILE *Qfile;
                
                void print_m(float tempo)
       ##### -> {
                int mu;
                
       ##### -> for(mu=0;mu<p;mu++)
                {
       ##### -> 	fprintf(mvari, "%.2f	%.4f	%d\n", tempo, m[mu], mu);
                }
                
       ##### -> }
                
                void read_pattern()
           1 -> {
                int i, mu;
           1 -> pat=fopen("pattern.dat","r");
                //	pat=fopen("spatt.txt","r");	
           1 -> for(mu=0;mu<p;mu++)
                {
           1 -> 	for(i=0;i<N;i++)
                	{
           1 -> 		fscanf(pat, "%d", &xi[i][mu]);
                	}
                }
           1 -> fclose(pat);
           1 -> }
                
                void initializing()
          10 -> {
                int i, j, l, k, mu;
                float qs, ma, maa;
                int i_c, x, new_one;
                
                /// inizializzo da file
                
          10 -> for(i=0;i<N;i++)								
                {										
          10 -> 	for(k=0;k<S;k++)
                	{
          10 -> 	s[i][k]=(-2*beta-2*exp(beta*U)-2*S+sqrt(pow(2*beta+2*exp(beta*U)+2*S,2)+8*(-beta*beta-2*beta*S+2*beta*S*exp(beta*U))))/(2*(-beta*beta-2*beta*S+2*beta*S*exp(beta*U)));  //soluzione per lo stato sazionario sviluppata attorno a s[i][k]=0
                	}	
          10 -> s[i][S]=1.-S*s[i][0];
          10 -> r[i][S]=1.-s[i][S];
                }
                
                ///		Cij		///33333333333333333333333333333333333333333
                
          10 -> for(i=0; i<N; i++)
                {
                //	C[i][0] = i;									/// per self sustained serve per stabilizzare il campo
                //	i_c = 1; 
          10 -> 	i_c = 0; 										/// considero Cii=0 ma poi per stabilizzare il campo agisco direttamente quando calcolo h    
          10 -> 	while(i_c<Cm)
                	{
          10 -> 		new_one = 1;
                ///		FULLY connected
                // 		j=i_c;			
                // 		if(j==i) 
                // 		{
                // 			new_one = 0;				
                // 			i_c++;
                // //printf("%d	\n", i_c);
                // 		}
                ///		SPARSE connected
          10 -> 		j = (int)((double)N*drand48());
          10 -> 		if(j==i) new_one = 0;						/// per porre Cii=0
          10 -> 		for(x=0; x<i_c; x++)						/// per controllare di non averlo gia` preso
                		{
          10 -> 			if(C[i][x]==j) new_one = 0;	
                		}
                ///
          10 -> 		if(new_one)
                		{
          10 -> 			C[i][i_c] = j;
          10 -> 			i_c++;
                		}
                	}
                }
          10 -> printf("dopo	\n");
                
                /// stampo la matrice delle connessioni  Cij 
                // FILE *cij;
                // cij=fopen("Cij.txt","w");
                // 
                // for(i=0; i<N; i++)
                // {
                // 	for(x=0; x<Cm; x++)
                // 	{
                // 		fprintf(cij,"%d	",C[i][x]);
                // 	}
                // fprintf(cij,"	\n");
                // }
                // fclose(cij);
                
                
                ///		Jixkl		///33333333333333333333333333333333333333333
                
          10 -> for(i=0; i<N; i++)
                {
          10 -> 	for(x=0; x<Cm; x++)
                	{
          10 -> 		for(k=0; k<S; k++)
                		{
          10 -> 			for(l=0; l<S; l++)
                			{
          10 -> 			J[i][x][k][l]=0;
                
          10 -> 			for(mu=0; mu<p; mu++)	
          10 -> 					J[i][x][k][l]+=((float)(xi[i][mu]==k)-as)*((float)(xi[C[i][x]][mu]==l)-as);	
          10 -> 			J[i][x][k][l]=J[i][x][k][l]/denCm;
                //			J[i][x][k][l]=(J[i][x][k][l]*(float)((k==0)*(l==0)))/denCm;
                			}
                		}
                	}
                }
          10 -> printf("dopo3	\n");
                
                
                ///		M		///33333333333333333333333333333333333333333
                								
          10 -> for(mu=0;mu<p;mu++)								
                {	
          10 -> 	maa=0.;									
          10 -> 	for(i=0;i<N;i++)							
                	{
          10 -> 		ma=0.;
          10 -> 		for(k=0;k<S;k++)
                		{
          10 -> 			ma+=((float)(xi[i][mu]==k)-as)*s[i][k];				//to calculate m  
                		}
          10 -> 		maa+=ma;
                	}
          10 -> m[mu]=maa*invdenN;									//value of m[mu] for each mu
                }										
                
                /*
                ///		H , R , T 		///33333333333333333333333333333333333333333
                for(i=0;i<N;i++)								//to calculate h, r, theta
                {						
                	r[i][S]=0.;
                
                	for(k=0;k<S;k++)
                	{
                	h[i][k]=0.;
                	 for(x=0;x<Cm;x++)								
                	{
                		for(l=0;l<S;l++)								
                		{
                		 h[i][k]+=	J[i][x][k][l]*s[C[i][x]][l];	///	333333333333333333333333333333333333333
                		}
                	}
                	r[i][k]=h[i][k];	
                	theta[i][k]=s[i][k];								
                
                	}									
                }*/
                
                ///		H , R , T 		///33333333333333333333333333333333333333333
          10 -> for(i=0;i<N;i++)								//to calculate h, r, theta
                {						
          10 -> 	for(k=0;k<S;k++)
                	{
          10 -> 	h[i][k]=0.;
          10 -> 	 for(x=0;x<Cm;x++)								
                	{
          10 -> 		for(l=0;l<S;l++)								
                		{
          10 -> 		 h[i][k]+=	J[i][x][k][l]*s[C[i][x]][l];	///	333333333333333333333333333333333333333
                		}
                	}
          10 -> 	r[i][k]=h[i][k];			//valgono nello stato stazionario
          10 -> 	theta[i][k]=s[i][k];		//valgono nello stato stazionario
                	}									
                }
                
          10 -> }
                
                void update_stato(int i, int n)
        6000 -> {
                int   mu, k, x, v, l;
                float Z, rmax, t;
                float II[p], self;
                float INcost;
                float mII;
                int MKcost;
                
        6000 -> rmax=r[i][S];
                
                
                ///	update per tutti gli stati diversi da S	///////
        6000 -> self=0.;															// calcolo la auto eccitazione
        6000 -> for(l=0;l<S;l++)
                {
        6000 -> 	self+=s[i][l];
                }
        6000 -> self=ws*self; 
                
        6000 -> INcost	=	(float)(n>n0)*g*exp(-((n-n0)/((float)tau)));			/// campo iniziale &&&&&&&&&&&&@@@@@@@@@@@@@@@@@@
                
        6000 -> for(k=0;k<S;k++)
                {
                	///	di  h
        6000 -> 	h[i][k]=0.;
        6000 -> 	 for(x=0;x<Cm;x++)								
                	{
        6000 -> 		for(l=0;l<S;l++)								
                		{
        6000 -> 		 h[i][k]+=	J[i][x][k][l]*s[C[i][x]][l];
                		}
                	}
        6000 -> 	h[i][k]+=w*s[i][k]-self+ INcost*(xi[i][retr]==k);										//tolgo l`auto eccitazione
                	/// di sold, thteta, r
        6000 -> 	sold[i][k]=s[i][k];
                
        6000 -> 	theta[i][k]+=b2*(s[i][k]-theta[i][k]);								//update theta
        6000 -> 	r[i][k]+=b1*(h[i][k]-theta[i][k]-r[i][k]);								//update r
                	
        6000 -> 	if(r[i][k]>rmax)												//(per evitare l'overflow calcolando s)	
                	{
        6000 -> 		rmax=r[i][k];	
                	}
                }
                
                /// //////////	update rS e sold per S	///
        6000 -> sold[i][S]=s[i][S];
        6000 -> r[i][S]+=b3*(1.-s[i][S]-r[i][S]);
                
                /// //////////    UPDATE stato PER T!=0    ///////////////
        6000 -> Z=0.;
        6000 -> for(k=0;k<S;k++)
                {
        6000 -> 	Z+=exp(beta*(r[i][k]-rmax));
                }
        6000 -> Z+=exp(beta*(r[i][S]+U-rmax));							//modificato con nuova concezione di U
                
                float invZ;
                
        6000 -> invZ=1./Z;
                
        6000 -> for(k=0;k<S;k++)
                {
        6000 -> 	s[i][k]=invZ*exp(beta*(r[i][k]-rmax));						//update of s[]
                }
        6000 -> s[i][S]=invZ*exp(beta*(r[i][S]-rmax+U));
                
                
                /*
                /// //////////    UPDATE H
                t=(float)n/N;
                //if((n%tempostampa)==0 && n>=10000*N)	
                if((n%tempostampa)==0)				
                {
                
                H=0.;
                Hq=0.;
                Hht=0.;
                	for(v=0;v<N;v++)
                	{
                		for(k=0;k<S;k++)
                		{
                		Hq+=-h[v][k]*s[v][k]/2.;   //manca k=0!!!!!
                		Hht+=-h[v][k]*s[v][k]/2.+theta[v][k]*s[v][k];
                		H+=-h[v][k]*s[v][k]/2.+(U+theta[v][k]+r[v][S])*s[v][k];  //il contributo di w e` gia` dentro h
                		}
                //	H+=-(theta[v][S]+U);  
                	}
                fprintf(Hqfile, "%.2f	%.4f\n", t, Hq);
                fprintf(Hfile, "%.2f	%.4f\n", t, H);
                fprintf(Hhtfile, "%.2f	%.4f\n", t, Hht);
                fflush(Hqfile);
                fflush(Hfile);
                fflush(Hhtfile);
                
                float A1, A2;
                A=0.;
                A1=0.;
                A2=0.;
                
                for(v=0;v<N;v++)
                {
                	for(k=0;k<S;k++)
                	{
                	A1+=0.5*(theta[v][k]*theta[v][k]-2*theta[v][k]*s[v][k]);
                	}
                A2+=0.5*(r[v][S]*r[v][S]-2*r[v][S]*(1-s[v][S]));
                }
                A=A1+A2;
                
                
                fprintf(Afile, "%.2f	%.2f\n", t, A);
                fprintf(A1file, "%.2f	%.2f\n", t, A1);
                fprintf(A2file, "%.2f	%.2f\n", t, A2);
                fflush(Afile);
                fflush(A1file);
                fflush(A2file);
                
                float TT, R0;
                TT=0.;
                R0=0.;
                for(v=0;v<N;v++)
                {
                	for(k=0;k<S;k++)
                	{
                	TT+=theta[v][k]/(float)N;
                	}
                R0+=r[v][S]/(float)N;
                }
                fprintf(Tfile, "%.2f	%.2f\n", t, TT);
                fprintf(R0file, "%.2f	%.2f\n", t, R0);
                fflush(Tfile);
                fflush(R0file);
                
                
                /// STAMPO DERIVATE
                
                float DT, DT0, DS;
                
                DT=0.;
                DT0=0.;
                DS=0.;
                
                for(v=0;v<N;v++)
                {
                	for(k=0;k<S;k++)
                	{
                	DT+=b2*fabs(s[v][k]-theta[v][k]);
                	DS+=fabs(s[v][k]-sold[v][k]);
                	}
                DT0+=b3*fabs(1.-s[v][S]-r[v][S]);
                DS+=fabs(s[v][S]-sold[v][S]);
                }
                
                
                // fprintf(DTfile, "%.2f	%.6f\n", t, b2*(s[2][1]-theta[2][1]));
                // fprintf(DSfile, "%.2f	%.6f\n", t, s[2][1]-sold[2][1]);
                // fprintf(DT0file, "%.2f	%.6f\n", t, s[2][1]);
                // fprintf(Tfile, "%.2f	%.6f\n", t, theta[2][1]);
                 fprintf(DTfile, "%.2f	%.6f\n", t, DT);
                // fprintf(DT0file, "%.2f	%.6f\n", t, DT0);
                 fprintf(DSfile, "%.2f	%.6f\n", t, DS);
                
                fflush(DTfile);
                fflush(DT0file);
                fflush(DSfile);
                }*/
        6000 -> }
                
                
                
                //printf("%.6f\n", s[i][k]-sold[i][k]);
                //printf("	%.6f\n", DS);
                //DS+=b3*fabs(h[v][k]-theta[v][k]-r[v][k]);
                
                
                
                
                
                
                
                void calcolo_m()
          10 -> {
                int  k,i, l, mu;
                float ma, maa;
                ///		M		///33333333333333333333333333333333333333333
                								
          10 -> for(mu=0;mu<p;mu++)								
                {	
          10 -> 	maa=0.;									
          10 -> 	for(i=0;i<N;i++)							
                	{
          10 -> 		ma=0.;
          10 -> 		for(k=0;k<S;k++)
                		{
          10 -> 			ma+=((float)(xi[i][mu]==k)-as)*s[i][k];				//to calculate m  
                		}
          10 -> 		maa+=ma;
                	}
          10 -> m[mu]=maa*invdenN;									//value of m[mu] for each mu
                }										
                
                
          10 -> }
                
                void getmemory()
           1 -> {
                int i, x, z;
                
           1 -> Permut= new int*[N];
           1 -> for(i=0; i<N; i++)
           1 -> 	Permut[i]=new int[NumSet];
                
           1 -> xi= new int*[N];
           1 -> for(i=0; i<N; i++)
           1 -> 	xi[i]=new int[p];
                
           1 -> s= new float*[N];
           1 -> for(i=0; i<N; i++)
           1 -> 	s[i]=new float[S+1];
                
           1 -> sold= new float*[N];
           1 -> for(i=0; i<N; i++)
           1 -> 	sold[i]=new float[S+1];
                
           1 -> h= new float*[N];
           1 -> for(i=0; i<N; i++)
           1 -> 	h[i]=new float[S];
                
           1 -> r= new float*[N];
           1 -> for(i=0; i<N; i++)
           1 -> 	r[i]=new float[S+1];
                
           1 -> theta= new float*[N];
           1 -> for(i=0; i<N; i++)
           1 -> 	theta[i]=new float[S];
                /*
                overlap= new float*[tstampato];
                for(i=0; i<tstampato; i++)
                	overlap[i]=new float[p];
                */
           1 -> J= new float***[N];
           1 -> for(i=0; i<N; i++)
                {	
           1 -> 	J[i]=new float**[N];
           1 -> 	 for(x=0; x<Cm; x++)
                	{	
           1 -> 		J[i][x]=new float*[S];
           1 -> 		 for(z=0; z<S; z++)
           1 -> 			J[i][x][z]=new float[S];
                	}
                }
                
                
                
           1 -> C= new int*[N];
           1 -> for(i=0; i<N; i++)
           1 -> 	C[i]=new int[Cm];
                
           1 -> }
                
                void deletememory()
           1 -> {
                int i;
                
           1 -> for(i=0; i<N; i++)
           1 -> 	delete (Permut[i]);
           1 -> delete(Permut);
                
           1 -> for(i=0; i<N; i++)
           1 -> 	delete (xi[i]);
           1 -> delete(xi);
                
                
           1 -> for(i=0; i<N; i++)
           1 -> 	delete (s[i]);
           1 -> delete(s);
                
           1 -> for(i=0; i<N; i++)
           1 -> 	delete (sold[i]);
           1 -> delete(sold);
                
           1 -> for(i=0; i<N; i++)
           1 -> 	delete (h[i]);
           1 -> delete(h);
                
           1 -> for(i=0; i<N; i++)
           1 -> 	delete (r[i]);
           1 -> delete(r);
                
           1 -> for(i=0; i<N; i++)
           1 -> 	delete (theta[i]);
           1 -> delete(theta);
                /*
                for(i=0; i<tstampato; i++)
                	delete (overlap[i]);
                delete(overlap);
                */
           1 -> }
                
                void SetUpTables()
           1 -> {
                int item, jtem, info;
                int fatto, kk;  
                
                //srand48(time(0));
           1 -> srand48(6937);
           1 -> for(kk=0; kk<NumSet; kk++)
                {
           1 -> 	item = 0; 
                	
           1 -> 	while(item<N)
                	{
                	
                	
           1 -> 	info =(int)((double)N*drand48());
                	
           1 -> 	fatto=0;
           1 -> 	while(fatto==0)
                	{
                	
           1 -> 		fatto=1;
                		
           1 -> 		for(jtem=0; jtem<item; jtem++)
                		{
           1 -> 			if(  Permut[jtem][kk] == info  )
                			{
           1 -> 				info=(info +1)-(int)((info+1)/N)*N;
           1 -> 				jtem=item;
           1 -> 				fatto=0;
                			}
                		}
                	
                	
                	}
                	
           1 -> 	Permut[item][kk]= info;
           1 -> 	item++;
                	}
                	
                }	
                
           1 -> }
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                


Top 10 Lines:

     Line      Count

      222       6000
       72         10
      404         10
       57          1
      428          1
      484          1
      523          1

Execution Summary:

      167   Executable lines in this file
      167   Lines executed
   100.00   Percent of the file executed

     6024   Total number of line executions
    36.07   Average executions per line
